#ifndef MINIMAC4_DOSAGE_WRITER_HPP
#define MINIMAC4_DOSAGE_WRITER_HPP

#include "variant.hpp"
#include "unique_haplotype.hpp"
#include "hidden_markov_model.hpp" // TODO: change imputed data class

#include <savvy/reader.hpp>
#include <savvy/writer.hpp>

#include <memory>

/**
 * @class dosage_writer
 * @brief Handles writing genotype and dosage data to VCF/BCF/SAV files.
 * 
 * This class manages writing variant information including dosages (HDS, LDS, DS),
 * genotype calls (GT), quality metrics (R2, ER2, call score), and optional empirical
 * dosage data. It supports temporary file merging, FORMAT/INFO field generation,
 * and optional output of site information.
 * 
 * The class also tracks imputation accuracy statistics for ER2 calculation.
 */
class dosage_writer
{
private:
  /**
   * @struct accuracy_statistics
   * @brief Stores cumulative ER2 statistics for a group of variants.
   */
  struct accuracy_statistics
  {
    double er2_sum = 0.;
    std::size_t n_var = 0;
  };

  savvy::writer out_file_;                        /**< Main output file writer */
  std::unique_ptr<savvy::writer> emp_out_file_;  /**< Optional empirical dosage output file */
  std::unique_ptr<savvy::writer> sites_out_file_;/**< Optional site info output file */
  std::unordered_set<std::string> fmt_field_set_;/**< Set of requested FORMAT fields */
  std::vector<accuracy_statistics> accuracy_stats_; /**< ER2 accuracy statistics */
  std::size_t n_samples_ = 0;                     /**< Number of samples in output */
  float min_r2_ = -1.f;                           /**< Minimum acceptable R2 for output */
  bool is_temp_file_;                              /**< Whether this is a temporary output file */

  // buffers
  savvy::compressed_vector<std::int8_t> sparse_gt_; /**< Sparse genotype calls */
  std::vector<float> dense_float_vec_;             /**< Dense floating-point buffer for GP/SD/DS */
  std::vector<float> dense_zero_vec_;              /**< Helper buffer for resetting dense vectors */

  /**
   * @struct variant_update_ctx
   * @brief Context structure used internally when updating variant FORMAT fields.
   */
  struct variant_update_ctx
  {
    savvy::compressed_vector<std::int8_t> sparse_gt;
    savvy::compressed_vector<float> sparse_dosages;
    std::vector<float> gp_vec;
  };
public:
  /**
   * @brief Construct a new dosage_writer.
   * 
   * @param file_path Path to main output file (VCF/BCF/SAV)
   * @param emp_file_path Optional path for empirical dosage output
   * @param sites_file_path Optional path for site info output
   * @param file_format Output file format (VCF/BCF/SAV)
   * @param out_compression Compression level for output file
   * @param sample_ids List of sample IDs for the output
   * @param fmt_fields List of FORMAT fields to include (GT, DS, GP, SD, HDS)
   * @param chromosome Chromosome identifier for VCF header
   * @param min_r2 Minimum R2 threshold for output variants
   * @param is_temp Whether the output is temporary (affects INFO/FORMAT fields)
   */
  dosage_writer(const std::string& file_path, const std::string& emp_file_path, const std::string& sites_file_path,
    savvy::file::format file_format,
    std::uint8_t out_compression,
    const std::vector<std::string>& sample_ids,
    const std::vector<std::string>& fmt_fields,
    const std::string& chromosome,
    float min_r2, bool is_temp);
  
  /**
   * @brief Merge temporary HDS and empirical dosage files into the final output.
   * 
   * This function reads records from multiple temporary files generated by
   * `dosage_writer`, merges the INFO and FORMAT fields (HDS, LDS, GT),
   * calculates allele frequencies, call scores, R2, and ER2 metrics,
   * and writes the combined data to the final output files.
   * 
   * The function supports optional empirical output (`emp_out_file_`) and
   * site information output (`sites_out_file_`). It also updates internal
   * accuracy statistics for ER2 calculation.
   * 
   * @param temp_files A list of readers for temporary dosage files (HDS, GT).
   * @param temp_emp_files A list of readers for temporary empirical dosage files (LDS, GT).
   * @return true if merging succeeded and all files are consistent.
   * @return false if any I/O error occurs or record/ploidy mismatches are detected.
   * 
   * @note The function assumes all temporary files have the same number of records
   * and consistent ploidy per sample. Any mismatch will cause an error and abort.
   * 
   * @note The merged HDS vector is used to generate the final FORMAT fields,
   * including DS, HDS, GP, and SD. INFO fields are recalculated across all
   * temporary files and may replace the intermediate S_X, S_XX, S_CS, and AN fields.
   * 
   * @note For ER2 calculation, missing LOO_S_YY values are currently approximated
   * by LOO_S_Y. This may need adjustment if missing values are available in temp files.
   * 
   * @warning Only haploid and diploid samples are fully supported for SD/GP calculations.
   * 
   * @warning Any inconsistencies in record counts across temp files or mismatch
   * between HDS, LDS, and GT vectors will abort the merge.
   */
  bool merge_temp_files(std::list<savvy::reader>& temp_files, std::list<savvy::reader>& temp_emp_files);
  bool merge_temp_files(std::list<std::string>& temp_file_paths, std::list<std::string>& temp_emp_file_paths);

  /**
   * @brief Write imputed dosages and observed genotypes to output files.
   *
   * This function iterates over the reference variants and target variants within
   * the imputation region, writing imputed dosages and observed genotype data 
   * into VCF/BCF output streams. It handles both typed (observed) target variants 
   * and imputed-only variants, attaches INFO/FORMAT annotations, and optionally 
   * writes additional site and empirical dosage outputs.
   *
   * Core responsibilities include:
   *  - Aligning reference haplotype variants with target variants.
   *  - Writing imputed dosages for all reference variants in the region.
   *  - Handling target-only variants (typed but not in reference).
   *  - Writing empirical leave-one-out (LOO) dosages when available.
   *  - Applying QC filters (e.g., r² thresholds) before writing.
   *  - Outputting to multiple streams: primary, site-only, and empirical.
   *
   * @param hmm_results 
   *   Container with HMM imputation results, including dosages and 
   *   leave-one-out (LOO) dosages for each reference variant.
   *
   * @param tar_variants 
   *   List of target variants that overlap with the reference panel
   *   (typed genotypes available for comparison).
   *
   * @param tar_only_variants 
   *   List of target variants not present in the reference panel
   *   (typed-only sites that need to be preserved).
   *
   * @param observed_range 
   *   Pair of indices defining the [first, last) sample range for which
   *   observed genotypes should be considered (supports batch writing).
   *
   * @param full_reference_data 
   *   Complete reference haplotype data (reduced representation),
   *   used to iterate through all reference variants in the region.
   *
   * @param impute_region 
   *   Genomic region currently being imputed (chromosome, start, end).
   *
   * @return true if the primary output file stream is still in a good state
   *         after writing all sites; false otherwise.
   *
   * @details
   * The algorithm proceeds in several phases:
   *  1. **Skip leading variants**: Both target and target-only iterators are 
   *     advanced until they reach the start of the imputation region.
   *  2. **Iterate through reference panel**:
   *     - For each reference variant:
   *       - Write any target-only variants that occur before or at this position.
   *       - Build an output site with imputed dosages from `hmm_results`.
   *       - If the site matches a typed target variant:
   *         - Add observed genotypes and leave-one-out dosages to INFO/FORMAT fields.
   *         - Optionally, write an empirical site record (typed + imputed).
   *       - If the site does not match a target variant:
   *         - Write only imputed dosages.
   *       - Sites passing QC (`has_good_r2`) are written to the primary output stream
   *         and optionally to a site-only output stream.
   *  3. **Flush trailing target-only variants**:
   *     - After finishing the reference loop, remaining target-only variants
   *       up to the end of the imputation region are written similarly.
   *
   * Variants are written in VCF/BCF format, with:
   *  - **INFO fields** (imputation quality metrics, typed/imputed flags).
   *  - **FORMAT fields** (dosages, genotypes, LOO dosages).
   *
   * @note
   * - INFO fields written include imputation quality metrics (e.g., Rsq).
   * - FORMAT fields written include dosages (DS) and optionally observed genotypes (GT).
   * - Sites are only written if they pass quality filters (e.g., has_good_r2()).
   * - Empirical outputs are written when both typed and imputed data are available.
   *
   * @dot
   * digraph WriteDosages {
   *   node [shape=box, style=rounded, fontsize=10];
   *   Start -> "Skip leading variants";
   *   "Skip leading variants" -> "Iterate over reference variants";
   *   "Iterate over reference variants" -> "Target-only before ref?";
   *   "Target-only before ref?" -> "Write target-only site" [label="yes"];
   *   "Target-only before ref?" -> "Build imputed site" [label="no"];
   *   "Build imputed site" -> "Matches target variant?";
   *   "Matches target variant?" -> "Add GT + LOO, write empirical" [label="yes"];
   *   "Matches target variant?" -> "Write imputed-only site" [label="no"];
   *   "Add GT + LOO, write empirical" -> "QC filter (r²)";
   *   "Write imputed-only site" -> "QC filter (r²)";
   *   "QC filter (r²)" -> "Write to output streams";
   *   "Iterate over reference variants" -> End;
   *   "Write to output streams" -> End;
   *   End [shape=oval];
   * }
   * @enddot
   */

  bool write_dosages(const full_dosages_results& hmm_results, const std::vector<target_variant>& tar_variants, const std::vector<target_variant>& tar_only_variants, std::pair<std::size_t, std::size_t> observed_range, const reduced_haplotypes& full_reference_data, const savvy::region& impute_region);
  
  /**
   * @brief Print the mean empirical R² (ER2) values to an output stream.
   *
   * This function computes and writes the mean ER2 values across all
   * accuracy statistic bins that have been tracked during imputation.
   * For each bin, the mean ER2 is calculated as:
   *
   * \f[
   *   \text{mean ER2} = \frac{\text{er2_sum}}{\text{n_var}}
   * \f]
   *
   * where `er2_sum` is the sum of empirical R² values for the bin,
   * and `n_var` is the number of variants contributing to the bin.
   * If a bin contains no variants (`n_var == 0`), a dot (`"."`) is printed instead.
   *
   * The output is printed as a single line, prefixed by `"Mean ER2:"`,
   * followed by space-separated values (or dots) for each bin.
   *
   * Example output:
   * @code
   * Mean ER2: 0.85 0.72 . 0.90
   * @endcode
   *
   * @param os
   *   The output stream to which the mean ER2 values should be written.
   *
   * @note
   * - This function does not modify internal state.
   * - Requires that `accuracy_stats_` has been populated during the imputation process.
   */
  void print_mean_er2(std::ostream& os) const;

private:

  /**
   * @brief Perform mean imputation on missing dosage values.
   *
   * This function replaces missing genotype dosage values in a sparse vector
   * with the mean of all observed (non-missing, non-special) values.
   *
   * The algorithm proceeds as follows:
   *  - Count the number of valid dosage values (`n`) and compute their sum.
   *  - Compute the mean as \f$ \text{mean} = \frac{s}{n} \f$, where
   *    \f$s\f$ is the sum of valid dosages.
   *  - Iterate through the vector again, replacing all values flagged as
   *    "missing" with the computed mean.
   *  - Special values (such as reserved markers defined in
   *    `savvy::typed_value`) are ignored when computing the mean and are
   *    left unchanged.
   *
   * @param sparse_dosages
   *   A compressed vector of dosage values to be imputed in-place.
   *
   * @return
   *   - `true` if at least one valid dosage was observed and mean imputation
   *     was performed.
   *   - `false` if no valid dosages were available (all missing/special).
   *
   * @note
   * - Only elements marked as "missing" are updated; "special" values remain unchanged.
   * - The imputation is done in-place, modifying the input vector directly.
   * - This is typically used for typed-only variants to fill in missing
   *   genotypes before downstream filtering and output.
   *
   * @see savvy::typed_value::is_missing
   * @see savvy::typed_value::is_special_value
   */
  static bool mean_impute(savvy::compressed_vector<float>& sparse_dosages);

  /**
   * @brief Generate VCF header key–value pairs for Minimac output.
   *
   * This function builds a vector of VCF header lines (as key–value pairs) 
   * describing metadata, INFO fields, and FORMAT fields for imputed/typed 
   * genotype data. The headers are used to initialize the output VCF/BCF files.
   *
   * @param fmt_fields 
   *   List of FORMAT field identifiers (e.g., "GT", "DS", "HDS", "GP", "SD") 
   *   that should be included in the header.
   *
   * @param chromosome 
   *   Chromosome identifier (e.g., `"1"`, `"X"`, `"chr2"`) used to populate 
   *   the `contig` field.
   *
   * @param is_temp 
   *   If `true`, generate headers for a temporary output file (intermediate 
   *   statistics with sums and LOO metrics).  
   *   If `false`, generate headers for the final imputed VCF (standard 
   *   INFO/FORMAT fields with allele frequency and accuracy metrics).
   *
   * @return 
   *   A vector of key–value pairs representing VCF header lines. 
   *   Each element has the form `{ key, value }`, where:
   *   - `key` is the VCF header section (`fileformat`, `filedate`, `INFO`, `FORMAT`, etc.).
   *   - `value` is the corresponding header line content.
   *
   * @details
   * - **Common fields**:  
   *   Both temporary and final headers include:
   *   - `fileformat=VCFv4.2`  
   *   - `filedate=<YYYYMMDD>`  
   *   - `source=Minimac v<VERSION>`  
   *   - `phasing=full`  
   *   - `contig=<ID=chromosome>`  
   *   - INFO flags for `IMPUTED` and `TYPED`
   *
   * - **Temporary header (`is_temp == true`)**:  
   *   Includes INFO fields with raw sums and leave-one-out statistics:
   *   - `AN, S_X, S_XX, S_CS, LOO_S_X, LOO_S_XX, LOO_S_Y, LOO_S_YY, LOO_S_XY`
   *
   * - **Final header (`is_temp == false`)**:  
   *   Includes INFO fields with summary statistics and accuracy metrics:
   *   - `AF, MAF, AVG_CS, R2, ER2`
   *
   * - **Dynamic FORMAT fields**:  
   *   Added based on `fmt_fields`:
   *   - `GT` → Genotype string  
   *   - `DS` → Dosage (expected alternate allele count)  
   *   - `HDS` → Haploid dosage  
   *   - `GP` → Posterior genotype probabilities  
   *   - `SD` → Variance of posterior probabilities  
   *
   * Example (final header with `GT` and `DS`):
   * @code
   * fileformat    VCFv4.2
   * filedate      20250819
   * source        Minimac v4.0.0
   * phasing       full
   * contig        <ID=1>
   * INFO          <ID=AF,Number=A,Type=Float,Description="Estimated Alternate Allele Frequency">
   * INFO          <ID=R2,Number=1,Type=Float,Description="Estimated Imputation Accuracy (R-square)">
   * FORMAT        <ID=GT,Number=1,Type=String,Description="Genotype">
   * FORMAT        <ID=DS,Number=A,Type=Float,Description="Estimated Alternate Allele Dosage : [P(0/1)+2*P(1/1)]">
   * @endcode
   *
   * @dot
   * digraph GenHeaders {
   *   node [shape=box, style=rounded, fontsize=10];
   *   Start -> "Common fields";
   *   "Common fields" -> "Check is_temp?";
   *   "Check is_temp?" -> "Add TEMP INFO fields (AN, S_X, LOO stats)" [label="true"];
   *   "Check is_temp?" -> "Add FINAL INFO fields (AF, MAF, R2, ER2)" [label="false"];
   *   "Add TEMP INFO fields (AN, S_X, LOO stats)" -> "Add dynamic FORMAT fields";
   *   "Add FINAL INFO fields (AF, MAF, R2, ER2)" -> "Add dynamic FORMAT fields";
   *   "Add dynamic FORMAT fields" -> End;
   *   End [shape=oval];
   * }
   * @enddot
   *
   * @note
   * - The `filedate` is automatically generated at runtime.
   * - Temporary headers are primarily used for internal QC and debugging.
   * - Final headers are used for the distributed imputed VCF/BCF files.
   */
  static std::vector<std::pair<std::string, std::string>> gen_headers(const std::vector<std::string>& fmt_fields, const std::string& chromosome, bool is_temp);
  
  /**
   * @brief Generate VCF header key–value pairs for empirical (leave-one-out) evaluation.
   *
   * This function builds a set of VCF header lines used for empirical accuracy
   * assessment of Minimac imputation. The header describes common VCF metadata,
   * INFO flags for imputation/typing, and FORMAT fields required for leave-one-out
   * dosage evaluation.
   *
   * @param chromosome 
   *   Chromosome identifier (e.g., `"1"`, `"X"`, `"chr2"`) used to populate 
   *   the `contig` header line.
   *
   * @return 
   *   A vector of key–value pairs representing VCF header lines. 
   *   Each element has the form `{ key, value }`, where:
   *   - `key` is the VCF header section (`fileformat`, `filedate`, `INFO`, `FORMAT`, etc.).
   *   - `value` is the corresponding header line content.
   *
   * @details
   * - **Common VCF fields** included:
   *   - `fileformat=VCFv4.2`
   *   - `filedate=<YYYYMMDD>` (current system date)
   *   - `source=Minimac v<VERSION>`
   *   - `phasing=full`
   *   - `contig=<ID=chromosome>`
   *
   * - **INFO flags**:
   *   - `IMPUTED` → Marker was imputed  
   *   - `TYPED`   → Marker was directly genotyped  
   *
   * - **FORMAT fields**:
   *   - `GT`  → Genotyped alleles from array  
   *   - `LDS` → Leave-one-out Imputed Dosage: Estimated haploid alternate allele 
   *             dosage assuming the site was *not* genotyped  
   *
   * Example:
   * @code
   * fileformat    VCFv4.2
   * filedate      20250819
   * source        Minimac v4.0.0
   * phasing       full
   * contig        <ID=1>
   * INFO          <ID=IMPUTED,Number=0,Type=Flag,Description="Marker was imputed">
   * INFO          <ID=TYPED,Number=0,Type=Flag,Description="Marker was genotyped">
   * FORMAT        <ID=GT,Number=1,Type=String,Description="Genotyped alleles from Array">
   * FORMAT        <ID=LDS,Number=.,Type=Float,Description="Leave-one-out Imputed Dosage : Estimated Haploid Alternate Allele Dosage assuming site was NOT genotyped">
   * @endcode
   *
   * @dot
   * digraph GenEmpHeaders {
   *   node [shape=box, style=rounded, fontsize=10];
   *   Start -> "Common fields";
   *   "Common fields" -> "Add INFO flags (IMPUTED, TYPED)";
   *   "Add INFO flags (IMPUTED, TYPED)" -> "Add FORMAT fields (GT, LDS)";
   *   "Add FORMAT fields (GT, LDS)" -> End;
   *   End [shape=oval];
   * }
   * @enddot
   *
   * @note
   * - The `filedate` is automatically generated at runtime.
   * - These headers are used for empirical accuracy evaluation (leave-one-out),
   *   not for final imputed VCF files.
   * - A `command` header line could be added later to store run parameters.
   */
  static std::vector<std::pair<std::string, std::string>> gen_emp_headers(const std::string& chromosome);

  /**
   * @brief Infer output file format from filename extension.
   *
   * Determines the appropriate `savvy::file::format` based on common
   * file extensions. If no recognized extension is found, the provided
   * `default_format` is returned.
   *
   * @param filename 
   *   Name of the file (may include path). Only the suffix is inspected.
   *
   * @param default_format 
   *   Format to return if the filename does not match a known extension.
   *
   * @return 
   *   Detected `savvy::file::format`, one of:
   *   - `savvy::file::format::sav` → `.sav` or `.usav`  
   *   - `savvy::file::format::bcf` → `.bcf` or `.ubcf`  
   *   - `savvy::file::format::vcf` → `.vcf` or `.vcf.gz`  
   *   - `default_format` if no match  
   *
   * @details
   * Supported extensions and their mappings:
   * - `.sav`   → SAV format  
   * - `.usav`  → SAV format (uncompressed variant)  
   * - `.bcf`   → BCF format  
   * - `.ubcf`  → BCF format (uncompressed variant)  
   * - `.vcf`   → VCF format  
   * - `.vcf.gz`→ VCF format (compressed)  
   *
   * Example:
   * @code
   * savvy::file::format fmt;
   * fmt = dosage_writer::format_from_filename("output.sav", savvy::file::format::vcf);
   * // fmt == savvy::file::format::sav
   *
   * fmt = dosage_writer::format_from_filename("output.unknown", savvy::file::format::vcf);
   * // fmt == savvy::file::format::vcf (default returned)
   * @endcode
   *
   * @dot
   * digraph FormatFromFilename {
   *   node [shape=box, style=rounded, fontsize=10];
   *   Start -> ".sav / .usav" [label="→ sav"];
   *   Start -> ".bcf / .ubcf" [label="→ bcf"];
   *   Start -> ".vcf / .vcf.gz" [label="→ vcf"];
   *   Start -> Default [label="else"];
   *   Default [shape=oval, label="Return default_format"];
   * }
   * @enddot
   */
  static savvy::file::format format_from_filename(const std::string& filename, savvy::file::format default_format);

  /**
   * @brief Infer compression level from filename extension.
   *
   * Determines a recommended compression level (0 = uncompressed, 6 = compressed)
   * based on the file suffix. If no recognized extension is found, returns the
   * provided `default_clevel`.
   *
   * @param filename
   *   File name (with optional path). Only the extension is inspected.
   *
   * @param default_clevel
   *   Compression level to return if the filename does not match a known extension.
   *
   * @return
   *   Compression level, one of:
   *   - `6` → for compressed formats (`.sav`, `.bcf`, `.vcf.gz`)  
   *   - `0` → for uncompressed formats (`.vcf`, `.usav`, `.ubcf`)  
   *   - `default_clevel` if no match  
   *
   * @details
   * Supported extensions and their default compression levels:
   * - `.sav`    → 6 (compressed SAV)  
   * - `.usav`   → 0 (uncompressed SAV)  
   * - `.bcf`    → 6 (compressed BCF)  
   * - `.ubcf`   → 0 (uncompressed BCF)  
   * - `.vcf`    → 0 (plain text VCF)  
   * - `.vcf.gz` → 6 (bgzipped VCF)  
   *
   * Example:
   * @code
   * int clevel;
   * clevel = dosage_writer::clevel_from_filename("output.sav", 1);
   * // clevel == 6
   *
   * clevel = dosage_writer::clevel_from_filename("output.vcf", 1);
   * // clevel == 0
   *
   * clevel = dosage_writer::clevel_from_filename("output.unknown", 1);
   * // clevel == 1 (default returned)
   * @endcode
   *
   * @dot
   * digraph CompressionLevel {
   *   node [shape=box, style=rounded, fontsize=10];
   *   Start -> ".sav / .bcf / .vcf.gz" [label="→ 6 (compressed)"];
   *   Start -> ".vcf / .usav / .ubcf" [label="→ 0 (uncompressed)"];
   *   Start -> Default [label="else"];
   *   Default [shape=oval, label="Return default_clevel"];
   * }
   * @enddot
   */
  static int clevel_from_filename(const std::string& filename, int default_clevel);

  /**
   * @brief Check whether a target variant matches a reference site.
   *
   * Compares genomic position and allele strings to determine equality.
   *
   * @param t
   *   The target variant (typically the imputed or observed variant).
   *
   * @param r
   *   The reference site information (typically from the reference panel).
   *
   * @return
   *   `true` if:
   *   - `t.pos == r.pos`, and  
   *   - `t.ref == r.ref`, and  
   *   - `t.alt == r.alt`  
   *   otherwise `false`.
   *
   * @note
   * This function performs a strict match — no normalization of alleles
   * (e.g., trimming common prefixes/suffixes) or case folding is applied.
   *
   * Example:
   * @code
   * target_variant tv{10023, "A", "G"};
   * reference_site_info rs{10023, "A", "G"};
   *
   * if (dosage_writer::sites_match(tv, rs)) {
   *     // sites are identical
   * }
   * @endcode
   */
  static bool sites_match(const target_variant& t, const reference_site_info& r);

  /**
   * @brief Check if a site passes the minimum imputation quality threshold (R²).
   *
   * This function retrieves the INFO field `"R2"` from a given site and
   * compares it against the user-defined minimum threshold (`min_r2_`).
   *
   * Behavior:
   * - If `min_r2_ < 0`, no filtering is applied and the function always returns `true`.
   * - Otherwise:
   *   - The `"R2"` value is extracted from the site (defaulting to `-1.0` if missing).
   *   - If `R2 >= min_r2_`, the site is considered "good" and the function returns `true`.
   *   - Otherwise, returns `false`.
   *
   * @param site
   *   The site record containing INFO annotations.
   *
   * @return
   *   `true` if the site passes the R² threshold filter, or if filtering is disabled;
   *   `false` otherwise.
   *
   * @note
   * - If `"R2"` is missing, the site automatically fails (since `r2` remains `-1.0`).
   * - This filter is commonly used to exclude poorly imputed variants from
   *   downstream analysis.
   *
   * @f[
   * \text{accept}(site) =
   * \begin{cases}
   * \text{true},  & \text{if } \min R^2 < 0 \\
   * \text{true},  & \text{if } R^2 \ge \min R^2 \\
   * \text{false}, & \text{otherwise}
   * \end{cases}
   * @f]
   *
   * @see savvy::site_info::get_info
   */
  bool has_good_r2(savvy::site_info& site);

  /**
   * @brief Compute the empirical squared correlation coefficient (R²) 
   *        between two sets of values.
   *
   * This function estimates the squared Pearson correlation coefficient 
   * between vectors X and Y, given their pre-computed summary statistics:
   *
   * @f[
   *   R^2 = 
   *   \frac{\left( n \cdot \sum xy - \sum x \cdot \sum y \right)^2}
   *        {\left( n \cdot \sum xx - (\sum x)^2 \right) 
   *         \left( n \cdot \sum yy - (\sum y)^2 \right)}
   * @f]
   *
   * where:
   * - @f$\sum x@f$ = sum of X values
   * - @f$\sum xx@f$ = sum of squared X values
   * - @f$\sum y@f$ = sum of Y values
   * - @f$\sum yy@f$ = sum of squared Y values
   * - @f$\sum xy@f$ = sum of cross-products (X * Y)
   * - @f$n@f$ = number of paired observations
   *
   * @param s_x   Sum of X values.
   * @param s_xx  Sum of squared X values.
   * @param s_y   Sum of Y values.
   * @param s_yy  Sum of squared Y values.
   * @param s_xy  Sum of cross-products of X and Y.
   * @param n     Number of samples (observations).
   *
   * @return 
   *   The empirical squared correlation coefficient (R²).
   *   Returns `0.0f` if the denominator is non-positive 
   *   (e.g., due to lack of variance).
   *
   * @note
   * - This implementation guards against negative denominators by clamping 
   *   variance terms with `std::max(0., ...)`.
   * - If either X or Y has zero variance, the result will be `0.0f`.
   */
  static float calc_er2(double s_x, double s_xx, double s_y, double s_yy, double s_xy, std::size_t n);

  /**
   * @brief Compute the estimated imputation quality metric (R²) 
   *        for dosages against Hardy–Weinberg variance.
   *
   * This function calculates the squared correlation between observed 
   * dosages and their expected binomial distribution, using the formula:
   *
   * @f[
   *   R^2 = 
   *   \frac{\frac{1}{n} \left( \max \bigl( 0, \; \sum xx - \frac{(\sum x)^2}{n} \bigr) \right)}
   *        { \; \hat{p}(1 - \hat{p}) \;}
   * @f]
   *
   * where:
   * - @f$\sum x@f$   = sum of dosages (X)
   * - @f$\sum xx@f$  = sum of squared dosages (X²)
   * - @f$n@f$        = number of samples
   * - @f$\hat{p} = \frac{\sum x}{n}@f$ = estimated allele frequency
   *
   * @param s_x   Sum of dosages across all samples.
   * @param s_xx  Sum of squared dosages across all samples.
   * @param n     Number of samples.
   *
   * @return 
   *   Estimated squared correlation coefficient (R²).
   *   Returns `0.0f` if the allele frequency variance term 
   *   @f$\hat{p}(1-\hat{p})@f$ is zero (i.e., monomorphic site).
   *
   * @note
   * - The numerator is clamped at zero via `std::max(0., ...)` 
   *   to prevent negative variance due to floating-point precision.
   * - This definition is commonly used in imputation software 
   *   (e.g., Minimac/Beagle) as an imputation quality score.
   */
  static float calc_r2(double s_x, double s_xx, std::size_t n);

  /**
   * @brief Populate INFO fields for an imputed variant record.
   *
   * This method computes summary statistics from imputed dosages and 
   * (optionally) observed genotypes, and writes them into the INFO 
   * fields of the output `variant`. 
   *
   * Two modes are supported:
   * - **Temporary mode** (`is_temp_file_ = true`): store raw summary
   *   aggregates (e.g., sums, cross-products) needed for later
   *   calculations.
   * - **Final mode** (`is_temp_file_ = false`): store derived statistics 
   *   commonly reported in VCFs, such as allele frequency (AF),
   *   minor allele frequency (MAF), average certainty (AVG_CS),
   *   and imputation quality scores (R² / ER²).
   *
   * Specifically, this function computes:
   * - **Dosage-based stats**
   *   - AN: number of non-missing samples (temp mode)
   *   - S_X, S_XX: sums of dosages and squared dosages (temp mode)
   *   - S_CS: certainty score sum (temp mode)
   *   - AF, MAF: allele frequencies (final mode)
   *   - AVG_CS: average certainty score (final mode)
   *   - R2: estimated imputation R² (final mode; see calc_r2)
   *
   * - **Leave-one-out (LOO) stats** (if LOO dosages and observed genotypes provided)
   *   - LOO_S_X, LOO_S_XX, LOO_S_Y, LOO_S_YY, LOO_S_XY: raw sums and cross-products (temp mode)
   *   - ER2: empirical squared correlation between observed genotypes 
   *          and leave-one-out dosages (final mode; see calc_er2)
   *   - Per-MAF-bin accuracy tracking: accumulates ER² into 
   *     `accuracy_stats_` for later summary.
   *
   * - **Flags**
   *   - TYPED: set if observed genotypes are available
   *   - IMPUTED: set if imputed dosages are present (or if no observed data)
   *
   * @param[out] out_var 
   *   The variant record to annotate with INFO fields.
   *
   * @param[in] sparse_dosages 
   *   Compressed vector of imputed dosages for all samples.
   *
   * @param[in] loo_dosages 
   *   Leave-one-out dosages (same length as `observed`), or empty if not available.
   *
   * @param[in] observed 
   *   Observed hard genotype calls (0/1), used for empirical R² 
   *   estimation. Must match size of `loo_dosages`.
   *
   * @note 
   * - Missing values in dosages are handled by `plus_ignore_missing`.
   * - Certainty score (CS) is defined as the maximum probability 
   *   among reference vs. alternate allele assignments.
   * - Allele frequency (AF) is computed from non-missing dosages.
   */
  void set_info_fields(savvy::variant& out_var, const savvy::compressed_vector<float>& sparse_dosages, const std::vector<float>& loo_dosages, const std::vector<std::int8_t>& observed);
  
  /**
   * @brief Populate FORMAT fields for an imputed variant record.
   *
   * This method writes per-sample fields (e.g., GT, HDS, GP, SD, DS)
   * into the output variant based on the requested FORMAT keys in
   * `fmt_field_set_`. It supports both haploid and diploid samples.
   *
   * Specifically, this function handles:
   *
   * - **GT (Genotype calls)**  
   *   - Derived from dosages (rounded: <0.5 → 0, ≥0.5 → 1).  
   *   - Stored sparsely to save space.  
   *   - Requires "GT" in `fmt_field_set_`.  
   *   - Note: assumes mean-imputation is performed for missing target-only
   *     variants; otherwise the commented-out "missing" case must be enabled.  
   *
   * - **HDS (Hard Dosage values)**  
   *   - Direct copy of the (possibly sparse) imputed dosages.  
   *   - If "HDS" not requested, sets an empty field.  
   *
   * - **GP (Genotype probabilities)**  
   *   - Expanded dense probabilities derived from dosages.  
   *   - Haploid: two probabilities [ref, alt].  
   *   - Diploid: three probabilities [P(0/0), P(0/1), P(1/1)].  
   *   - Uses a dense vector (`dense_float_vec_`).  
   *
   * - **SD (Standard deviation of genotype)**  
   *   - Per-sample variance estimate derived from dosages.  
   *   - Haploid: var(dosage).  
   *   - Diploid: var from pair of allele dosages.  
   *   - Requires "SD" in `fmt_field_set_`.  
   *
   * - **DS (Dosage sum across ploidy)**  
   *   - Reduces haploid/diploid dosages into a single scalar dosage per sample.  
   *   - Implemented via `savvy::stride_reduce`.  
   *
   * @param[out] out_var
   *   The variant record to annotate with FORMAT fields.
   *
   * @param[in,out] sparse_dosages
   *   Compressed vector of imputed dosages (length = `n_samples_ * stride`).  
   *   Used for GT/HDS, and expanded into dense vectors for GP/SD.  
   *   Is modified in-place for DS reduction.
   *
   * @note
   * - This method temporarily expands sparse dosages into a dense vector
   *   (`dense_zero_vec_`) for GP/SD calculation, and resets it afterward.
   * - Currently only supports haploid (stride = 1) and diploid (stride = 2)
   *   samples. Higher ploidy triggers an error message for SD.
   */
  void set_format_fields(savvy::variant& out_var, savvy::compressed_vector<float>& sparse_dosages);

  /**
   * @brief Binary functor that performs addition while ignoring missing values.
   *
   * This operator is designed for use in aggregation/reduction where some inputs
   * may be missing, encoded differently depending on the data type.
   *
   * - For `float`:  
   *   - Missing values are represented as `NaN`.  
   *   - If one operand is `NaN`, the other operand is returned.  
   *   - If both are valid, their sum is returned.
   *
   * - For `std::int32_t`:  
   *   - Missing values are represented as any negative number.  
   *   - If one operand is missing (< 0), the other operand is returned.  
   *   - If both are valid (≥ 0), their sum is returned.
   *
   * Example usage:
   * @code
   * plus_ignore_missing add;
   * float a = 1.2f, b = std::numeric_limits<float>::quiet_NaN();
   * float result = add(a, b); // result = 1.2f
   *
   * std::int32_t x = 3, y = -1;
   * std::int32_t int_result = add(x, y); // int_result = 3
   * @endcode
   */
  struct plus_ignore_missing
  {
    float operator()(const float& l, const float& r)
    {
      if (std::isnan(r))
        return l;
      if (std::isnan(l))
        return r;
      return l + r;
    }

    std::int32_t operator()(const std::int32_t& l, const std::int32_t& r)
    {
      if (r < 0)
        return l;
      if (l < 0)
        return r;
      return l + r;
    }
  };
};

#endif // MINIMAC4_DOSAGE_WRITER_HPP
