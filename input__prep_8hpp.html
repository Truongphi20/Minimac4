<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" class="light-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Minimac4: src/input_prep.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Minimac4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">input_prep.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="unique__haplotype_8hpp_source.html">unique_haplotype.hpp</a>&quot;</code><br />
<code>#include &lt;savvy/reader.hpp&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for input_prep.hpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp__incl.svg" width="947" height="342"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp__dep__incl.svg" width="391" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="input__prep_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acff4e7b0582e787ee4db091caa685c7b" id="r_acff4e7b0582e787ee4db091caa685c7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acff4e7b0582e787ee4db091caa685c7b">stat_tar_panel</a> (const std::string &amp;tar_file_path, std::vector&lt; std::string &gt; &amp;sample_ids)</td></tr>
<tr class="memdesc:acff4e7b0582e787ee4db091caa685c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract sample IDs from a target panel file.  <br /></td></tr>
<tr class="separator:acff4e7b0582e787ee4db091caa685c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6e4e9a5365a63291b1eeb571d9308" id="r_a5dc6e4e9a5365a63291b1eeb571d9308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dc6e4e9a5365a63291b1eeb571d9308">stat_ref_panel</a> (const std::string &amp;ref_file_path, std::string &amp;chrom, std::uint64_t &amp;end_pos)</td></tr>
<tr class="memdesc:a5dc6e4e9a5365a63291b1eeb571d9308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspect a reference panel file to determine chromosome and end position.  <br /></td></tr>
<tr class="separator:a5dc6e4e9a5365a63291b1eeb571d9308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de162b6e2c02f48cc2818b71cbf6f4c" id="r_a9de162b6e2c02f48cc2818b71cbf6f4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de162b6e2c02f48cc2818b71cbf6f4c">load_target_haplotypes</a> (const std::string &amp;file_path, const savvy::genomic_region &amp;reg, std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;target_sites, std::vector&lt; std::string &gt; &amp;sample_ids)</td></tr>
<tr class="memdesc:a9de162b6e2c02f48cc2818b71cbf6f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load haplotypes from a target file for a given genomic region.  <br /></td></tr>
<tr class="separator:a9de162b6e2c02f48cc2818b71cbf6f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b6160b69f849225374f36e12dab454" id="r_a31b6160b69f849225374f36e12dab454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31b6160b69f849225374f36e12dab454">load_reference_haplotypes</a> (const std::string &amp;file_path, const savvy::genomic_region &amp;extended_reg, const savvy::genomic_region &amp;impute_reg, const std::unordered_set&lt; std::string &gt; &amp;subset_ids, std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;target_sites, <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;typed_only_reference_data, <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;full_reference_data, <a class="el" href="classgenetic__map__file.html">genetic_map_file</a> *map_file, float min_recom, float default_match_error)</td></tr>
<tr class="memdesc:a31b6160b69f849225374f36e12dab454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and process reference haplotypes from an MVCF file.  <br /></td></tr>
<tr class="separator:a31b6160b69f849225374f36e12dab454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6103761cf74447b4a53fd6a17de447c" id="r_ae6103761cf74447b4a53fd6a17de447c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6103761cf74447b4a53fd6a17de447c">load_reference_haplotypes_old_recom_approach</a> (const std::string &amp;file_path, const savvy::genomic_region &amp;extended_reg, const savvy::genomic_region &amp;impute_reg, const std::unordered_set&lt; std::string &gt; &amp;subset_ids, std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;target_sites, <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;typed_only_reference_data, <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;full_reference_data, <a class="el" href="classgenetic__map__file.html">genetic_map_file</a> *map_file)</td></tr>
<tr class="memdesc:ae6103761cf74447b4a53fd6a17de447c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads reference haplotypes using an older recombination-based approach.  <br /></td></tr>
<tr class="separator:ae6103761cf74447b4a53fd6a17de447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361a1a76ebbe3b263e3163760007fa66" id="r_a361a1a76ebbe3b263e3163760007fa66"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a361a1a76ebbe3b263e3163760007fa66">separate_target_only_variants</a> (std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;target_sites)</td></tr>
<tr class="memdesc:a361a1a76ebbe3b263e3163760007fa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates target-only variants from those found in the reference panel.  <br /></td></tr>
<tr class="separator:a361a1a76ebbe3b263e3163760007fa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c14a19ad01f940f506c712b7c5b8ba" id="r_ad0c14a19ad01f940f506c712b7c5b8ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c14a19ad01f940f506c712b7c5b8ba">load_variant_hmm_params</a> (std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;tar_variants, <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;typed_only_reference_data, float default_error_param, float recom_min, const std::string &amp;map_file_path)</td></tr>
<tr class="memdesc:ad0c14a19ad01f940f506c712b7c5b8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads Hidden Markov Model (HMM) parameters for target variants.  <br /></td></tr>
<tr class="separator:ad0c14a19ad01f940f506c712b7c5b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fba53d7d33e4a0f719c8683dc761bff" id="r_a3fba53d7d33e4a0f719c8683dc761bff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fba53d7d33e4a0f719c8683dc761bff">generate_reverse_maps</a> (const <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;typed_only_reference_data)</td></tr>
<tr class="memdesc:a3fba53d7d33e4a0f719c8683dc761bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates reverse mapping tables for reduced haplotype blocks.  <br /></td></tr>
<tr class="separator:a3fba53d7d33e4a0f719c8683dc761bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6907198dc454fe5c57ec081be5698eac" id="r_a6907198dc454fe5c57ec081be5698eac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6907198dc454fe5c57ec081be5698eac">convert_old_m3vcf</a> (const std::string &amp;input_path, const std::string &amp;output_path, const std::string &amp;map_file_path=&quot;&quot;)</td></tr>
<tr class="memdesc:a6907198dc454fe5c57ec081be5698eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an old M3VCF file (v1/v2) to a newer VCF-like format (MVCFv3.0).  <br /></td></tr>
<tr class="separator:a6907198dc454fe5c57ec081be5698eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43f91655292959c9938600b0d7b63a" id="r_a7a43f91655292959c9938600b0d7b63a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a43f91655292959c9938600b0d7b63a">compress_reference_panel</a> (const std::string &amp;input_path, const std::string &amp;output_path, std::size_t min_block_size=10, std::size_t max_block_size=0xFFFF, std::size_t slope_unit=10, const std::string &amp;map_file_path=&quot;&quot;)</td></tr>
<tr class="memdesc:a7a43f91655292959c9938600b0d7b63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a haplotype reference panel into blocks and write to an output file.  <br /></td></tr>
<tr class="separator:a7a43f91655292959c9938600b0d7b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7a43f91655292959c9938600b0d7b63a" name="a7a43f91655292959c9938600b0d7b63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a43f91655292959c9938600b0d7b63a">&#9670;&#160;</a></span>compress_reference_panel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool compress_reference_panel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>output_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_block_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0xFFFF</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>slope_unit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>map_file_path</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress a haplotype reference panel into blocks and write to an output file. </p>
<p>This function reads a phased reference panel from an input file (VCF/BCF/SAV format), compresses haplotypes into blocks of unique haplotypes, and writes the result to an output file in SAV/BCF format. It adaptively determines when to flush blocks based on compression ratio and block size constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_path</td><td>Path to the input reference panel file (VCF/BCF/SAV). </td></tr>
    <tr><td class="paramname">output_path</td><td>Path to the compressed output file (SAV/BCF). </td></tr>
    <tr><td class="paramname">min_block_size</td><td>Minimum number of variants required in a block before flushing. </td></tr>
    <tr><td class="paramname">max_block_size</td><td>Maximum number of variants allowed in a block before forcing flush. </td></tr>
    <tr><td class="paramname">slope_unit</td><td>Interval of variants used to check compression ratio slope. </td></tr>
    <tr><td class="paramname">map_file_path</td><td>Path to a genetic map file (currently unused, reserved for CM filling).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if compression and writing completed successfully, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Input file must contain fully phased genotypes (phasing header must not be "none" or "partial").</li>
<li>INFO and FORMAT fields required for compressed blocks are automatically added to headers.</li>
<li>Compression ratio is defined as:     <p class="formulaDsp">
\[   CR = \frac{\text{expanded haplotype size} + 
   (\text{unique haplotype size} \times \text{variant size})}
   {\text{expanded haplotype size} \times \text{variant size}}
\]
</p>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classunique__haplotype__block.html" title="Represents a block of unique haplotypes and their variants.">unique_haplotype_block</a>, <a class="el" href="structreference__site__info.html" title="Stores information about a site in the reference dataset.">reference_site_info</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a7a43f91655292959c9938600b0d7b63a_cgraph.svg" width="392" height="334"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a7a43f91655292959c9938600b0d7b63a_icgraph.svg" width="267" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a6907198dc454fe5c57ec081be5698eac" name="a6907198dc454fe5c57ec081be5698eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6907198dc454fe5c57ec081be5698eac">&#9670;&#160;</a></span>convert_old_m3vcf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool convert_old_m3vcf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>output_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>map_file_path</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an old M3VCF file (v1/v2) to a newer VCF-like format (MVCFv3.0). </p>
<p>This function reads an input M3VCF file, updates its headers and records, and writes them to an output file in a modernized format compatible with downstream tools. Optionally, a genetic map file may be provided to annotate recombination positions.</p>
<p>Conversion steps include:</p><ul>
<li>Parsing and updating VCF/M3VCF header lines.</li>
<li>Ensuring presence of required <code>phasing</code> and <code>contig</code> headers.</li>
<li>Adding INFO and FORMAT metadata fields required by MVCFv3.0.</li>
<li>Reading sample IDs from the column header line.</li>
<li>Deserializing haplotype blocks from the input file.</li>
<li>Optionally annotating variants with centimorgan (cM) positions if a map file is provided.</li>
<li>Serializing blocks to the output file in the new format.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_path</td><td>Path to the old M3VCF file (gzipped). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_path</td><td>Path to the output file (can be <code>.bcf</code> or <code>.sav</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_file_path</td><td>Optional path to a genetic map file for cM annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the conversion completed successfully, false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If input or output files cannot be opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Supports M3VCF v1 and v2 input.</li>
<li>Output headers are modified to include MVCFv3.0 metadata.</li>
<li>If <code>map_file_path</code> is non-empty, records will include cM positions.</li>
<li>The function ensures <code>phasing</code> and <code>contig</code> headers exist.</li>
<li>Sample IDs are extracted from the first non-header line of the input.</li>
</ul>
</dd></dl>
<p>@complexity</p><ul>
<li>Time: O(B × V), where B = number of blocks, V = number of variants per block.</li>
<li>Memory: O(N), proportional to the size of haplotype data buffered during conversion. </li>
</ul>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a6907198dc454fe5c57ec081be5698eac_cgraph.svg" width="643" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a6907198dc454fe5c57ec081be5698eac_icgraph.svg" width="259" height="39"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a3fba53d7d33e4a0f719c8683dc761bff" name="a3fba53d7d33e4a0f719c8683dc761bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fba53d7d33e4a0f719c8683dc761bff">&#9670;&#160;</a></span>generate_reverse_maps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &gt; generate_reverse_maps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typed_only_reference_data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates reverse mapping tables for reduced haplotype blocks. </p>
<p>This function constructs a three-level nested vector structure (<code>reverse_maps</code>) that provides, for each block and each allele state in that block, the list of haplotype indices that map to it.</p>
<p>The mapping is inverted from the <code>unique_map()</code> representation in each block of the <code>typed_only_reference_data</code>.</p>
<p>Structure of the returned vector:</p><ul>
<li><code>reverse_maps[block_idx][allele_idx]</code> → list of haplotype indices that correspond to this allele in the given block.</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line">reverse_maps[b][a] = { h0, h1, h7 }</div>
</div><!-- fragment --><p> means in block <code>b</code>, allele <code>a</code> corresponds to haplotypes 0, 1, and 7.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typed_only_reference_data</td><td>Reference haplotype data partitioned into blocks, each containing allele cardinalities and a unique haplotype map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nested vector structure containing reverse maps for each block.</dd></dl>
<p>@complexity O(N), where N = total number of haplotype entries across all blocks.</p>
<dl class="section note"><dt>Note</dt><dd>Each block in <code>typed_only_reference_data</code> must have consistent <code>cardinalities()</code> and <code>unique_map()</code> values. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a3fba53d7d33e4a0f719c8683dc761bff_cgraph.svg" width="390" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a3fba53d7d33e4a0f719c8683dc761bff_icgraph.svg" width="486" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a31b6160b69f849225374f36e12dab454" name="a31b6160b69f849225374f36e12dab454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b6160b69f849225374f36e12dab454">&#9670;&#160;</a></span>load_reference_haplotypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_reference_haplotypes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const savvy::genomic_region &amp;</td>          <td class="paramname"><span class="paramname"><em>extended_reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const savvy::genomic_region &amp;</td>          <td class="paramname"><span class="paramname"><em>impute_reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subset_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typed_only_reference_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>full_reference_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgenetic__map__file.html">genetic_map_file</a> *</td>          <td class="paramname"><span class="paramname"><em>map_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min_recom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>default_match_error</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and process reference haplotypes from an MVCF file. </p>
<p>This function loads reference haplotypes within an extended genomic region from an MVCF (M3VCFv3/MVCFv3) file. It extracts haplotype blocks, aligns them with the provided target variants, computes allele frequencies, recombination probabilities, and compresses the resulting haplotype data into reduced representations for imputation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_path</td><td>Path to the MVCF reference haplotype file. </td></tr>
    <tr><td class="paramname">extended_reg</td><td>Genomic region to query from the reference file (with buffer for recombination). </td></tr>
    <tr><td class="paramname">impute_reg</td><td>Genomic region of interest for imputation (subset of <code class="param">extended_reg</code>). </td></tr>
    <tr><td class="paramname">subset_ids</td><td>Subset of sample IDs to extract from the reference file. If empty, all samples are included. </td></tr>
    <tr><td class="paramname">target_sites</td><td>Vector of target variants to be aligned and updated with reference information (allele frequency, error rate, recombination probability, etc.). </td></tr>
    <tr><td class="paramname">typed_only_reference_data</td><td>Output container for typed-only reference haplotypes, compressed. </td></tr>
    <tr><td class="paramname">full_reference_data</td><td>Output container for full reference haplotype data across the impute region. </td></tr>
    <tr><td class="paramname">map_file</td><td>Optional genetic map file for interpolation of centimorgan positions. If provided, recombination probabilities are computed from map distances. </td></tr>
    <tr><td class="paramname">min_recom</td><td>Minimum recombination probability to enforce between adjacent variants. </td></tr>
    <tr><td class="paramname">default_match_error</td><td>Default genotype matching error rate used when missing in the reference file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the haplotypes were successfully loaded and processed, false if an error occurred (e.g., file not found, wrong format, no overlapping samples).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The reference file must be indexed MVCFv3.0/M3VCFv3.0 format.</li>
<li>If no overlapping subset samples are found, the function fails.</li>
<li>Variants outside the imputation region are trimmed, but recombination probabilities are still updated based on <code class="param">extended_reg</code>.</li>
<li>For chromosome X, ensure PAR and non-PAR regions are imputed separately.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classreduced__haplotypes.html" title="Represents a collection of haplotype blocks with reduced storage.">reduced_haplotypes</a>, <a class="el" href="structtarget__variant.html" title="Represents a variant in the target dataset.">target_variant</a>, savvy::reader </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a31b6160b69f849225374f36e12dab454_cgraph.svg" width="695" height="643"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a31b6160b69f849225374f36e12dab454_icgraph.svg" width="506" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae6103761cf74447b4a53fd6a17de447c" name="ae6103761cf74447b4a53fd6a17de447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6103761cf74447b4a53fd6a17de447c">&#9670;&#160;</a></span>load_reference_haplotypes_old_recom_approach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_reference_haplotypes_old_recom_approach </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const savvy::genomic_region &amp;</td>          <td class="paramname"><span class="paramname"><em>extended_reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const savvy::genomic_region &amp;</td>          <td class="paramname"><span class="paramname"><em>impute_reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subset_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typed_only_reference_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>full_reference_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgenetic__map__file.html">genetic_map_file</a> *</td>          <td class="paramname"><span class="paramname"><em>map_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads reference haplotypes using an older recombination-based approach. </p>
<p>This function reads reference haplotypes from an MVCF/M3VCF file and integrates them with a set of target variants. It populates two reduced haplotype structures: one containing only variants overlapping with the target sites (<code>typed_only_reference_data</code>), and one containing all reference haplotypes within the imputation region (<code>full_reference_data</code>).</p>
<p>Recombination probabilities between consecutive variants are estimated using either the centimorgan positions from a provided genetic map (<code>map_file</code>) or the reference file annotations. Allele frequencies for overlapping target variants are updated based on reference genotypes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_path</td><td>Path to the reference haplotype file (MVCF/M3VCF format). </td></tr>
    <tr><td class="paramname">extended_reg</td><td>Genomic region specifying the extended window to load haplotypes from (includes buffer around imputation region). </td></tr>
    <tr><td class="paramname">impute_reg</td><td>Genomic region specifying the imputation window (used to trim full reference haplotype blocks). </td></tr>
    <tr><td class="paramname">subset_ids</td><td>Optional subset of sample IDs to restrict reference samples. If empty, all samples are used. </td></tr>
    <tr><td class="paramname">target_sites</td><td>Vector of target variants. This vector is updated with allele frequencies, reference overlap flags, and recombination estimates. </td></tr>
    <tr><td class="paramname">typed_only_reference_data</td><td>Output reduced haplotypes structure containing only variants overlapping with target sites. </td></tr>
    <tr><td class="paramname">full_reference_data</td><td>Output reduced haplotypes structure containing all haplotype blocks overlapping the imputation region. </td></tr>
    <tr><td class="paramname">map_file</td><td>Optional pointer to a genetic map file. If provided, used to interpolate centimorgan distances for recombination probability calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the reference haplotypes were successfully loaded and processed, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function supports both newer MVCFv3 and older M3VCF file formats. When an invalid or incompatible file is provided, an error message is printed and the function returns false.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The function assumes that the reference file is properly indexed (MVCF) or formatted (M3VCF). Errors in input files will terminate early. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_ae6103761cf74447b4a53fd6a17de447c_cgraph.svg" width="695" height="643"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9de162b6e2c02f48cc2818b71cbf6f4c" name="a9de162b6e2c02f48cc2818b71cbf6f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de162b6e2c02f48cc2818b71cbf6f4c">&#9670;&#160;</a></span>load_target_haplotypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_target_haplotypes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const savvy::genomic_region &amp;</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_sites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_ids</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load haplotypes from a target file for a given genomic region. </p>
<p>This function opens a VCF/BCF target file, extracts sample IDs, enforces ploidy consistency across all variants, and fills the list of target variants (<code>target_sites</code>) with genotypes encoded per allele.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_path</td><td>Path to the target VCF/BCF file. <br  />
 Must be bgzipped and indexed (CSI/TBI). </td></tr>
    <tr><td class="paramname">reg</td><td>Genomic region to query (chromosome, start, end). <br  />
 Bounds are applied using <code>savvy::reader::reset_bounds()</code>. <br  />
 If querying fails, the function returns false. </td></tr>
    <tr><td class="paramname">target_sites</td><td>Output vector that will be filled with <code><a class="el" href="structtarget__variant.html" title="Represents a variant in the target dataset.">target_variant</a></code> objects, each representing one ALT allele at a site. <br  />
 For multi-allelic sites, one entry per ALT allele is created. </td></tr>
    <tr><td class="paramname">sample_ids</td><td>Output vector of sample IDs extracted from the target file header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the haplotypes were successfully loaded and ploidy checks passed, <br  />
 false otherwise. On failure, descriptive error messages are printed to <code>stderr</code>.</dd></dl>
<ul>
<li>The function extracts genotypes (<code>GT</code> field) and converts them into binary encoding:<ul>
<li><b>Biallelic sites</b>: GT values are stored directly in <code><a class="el" href="structtarget__variant.html#a400e80e96a6dbfb4ed6e6d4b7bf4e7ba" title="Genotype data for each sample.">target_variant::gt</a></code>.</li>
<li><b>Multiallelic sites</b>: For each ALT allele, a separate <code><a class="el" href="structtarget__variant.html" title="Represents a variant in the target dataset.">target_variant</a></code> is created. <br  />
 The genotype array is recoded to indicate presence (1) or absence (0) of the allele.</li>
</ul>
</li>
<li>Ploidy consistency is checked:<ul>
<li>On first variant, sample ploidies are initialized.</li>
<li>On subsequent variants, <code><a class="el" href="input__prep_8cpp.html#a491123a3631453e6921a547d9349e2c9">check_ploidies()</a></code> ensures all samples retain the same ploidy.</li>
<li>If a sample’s ploidy changes mid-file, the function errors out.</li>
<li>Special warning is printed for chromosome X (<code>X</code> or <code>chrX</code>) due to PAR/non-PAR handling.</li>
</ul>
</li>
<li>For missing genotype values, <code>quiet_NaN()</code> is used as a placeholder for dosage fields.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Requires that the input file is properly indexed. Otherwise, region queries will fail.</li>
<li>If the function encounters ploidy changes, the run is aborted to avoid downstream phasing/imputation errors.</li>
<li>End users should split chromosome X into <b>PAR</b> and <b>non-PAR</b> regions before imputation.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Error messages are printed directly to <code>stderr</code>. <br  />
 This includes:<ul>
<li>File access errors (cannot open target file). <br  />
</li>
<li>Region query errors (file not indexed or invalid <code>reg</code>). <br  />
</li>
<li>Ploidy inconsistency across samples. </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a9de162b6e2c02f48cc2818b71cbf6f4c_cgraph.svg" width="351" height="91"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a9de162b6e2c02f48cc2818b71cbf6f4c_icgraph.svg" width="482" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ad0c14a19ad01f940f506c712b7c5b8ba" name="ad0c14a19ad01f940f506c712b7c5b8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c14a19ad01f940f506c712b7c5b8ba">&#9670;&#160;</a></span>load_variant_hmm_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_variant_hmm_params </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tar_variants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreduced__haplotypes.html">reduced_haplotypes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>typed_only_reference_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>default_error_param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>recom_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>map_file_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads Hidden Markov Model (HMM) parameters for target variants. </p>
<p>This function initializes error rates and recombination probabilities for a sequence of target variants by combining:</p><ul>
<li>Default error parameters.</li>
<li>Per-variant error estimates (if available).</li>
<li>Genetic map–based recombination rates (if a genetic map file is provided).</li>
</ul>
<p>Specifically:</p><ul>
<li>Each variant’s error parameter (<code>err</code>) is set either from the reference data or from <code>default_error_param</code> if missing (NaN).</li>
<li>Recombination probabilities (<code>recom</code>) are computed between consecutive variants using genetic map centiMorgan (cM) positions, converted to switch probabilities. If no map file is provided, previously loaded map positions in the reference data are used.</li>
<li>The last variant is always assigned <code>recom = 0.0f</code>, ensuring no recombination at the backward traversal boundary.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tar_variants</td><td>Vector of target variants whose HMM parameters (<code>err</code>, <code>recom</code>) will be filled. <br  />
 Must have the same size as the reference haplotype set. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">typed_only_reference_data</td><td>Reduced reference haplotype data aligned to <code>tar_variants</code>. <br  />
 Provides genetic map positions and optional error rates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_error_param</td><td>Default error parameter assigned if no error rate is provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recom_min</td><td>Minimum recombination probability allowed between adjacent variants. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_file_path</td><td>Path to the genetic map file. If empty, recombination rates are computed from existing positions in <code>typed_only_reference_data</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if parameters were successfully loaded; <br  />
 <code>false</code> if the variant list is empty or if the genetic map file cannot be opened.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function asserts that the number of target variants matches the number of reference variants. </dd>
<dd>
Input vectors are modified in place.</dd></dl>
<p>@complexity O(N), where N = number of variants. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_ad0c14a19ad01f940f506c712b7c5b8ba_cgraph.svg" width="443" height="315"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a361a1a76ebbe3b263e3163760007fa66" name="a361a1a76ebbe3b263e3163760007fa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361a1a76ebbe3b263e3163760007fa66">&#9670;&#160;</a></span>separate_target_only_variants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; separate_target_only_variants </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structtarget__variant.html">target_variant</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target_sites</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates target-only variants from those found in the reference panel. </p>
<p>This function partitions the input vector of target variants (<code>target_sites</code>) into two groups:</p><ul>
<li>Variants that are present in the reference (remain in <code>target_sites</code>).</li>
<li>Variants that are absent from the reference (<code>in_ref == false</code>) and are moved into a new vector (<code>target_only_sites</code>).</li>
</ul>
<p>The function maintains efficient memory usage by swapping elements in place rather than performing deep copies. After execution, <code>target_sites</code> will only contain variants found in the reference panel, and <code>target_only_sites</code> will contain all others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">target_sites</td><td>Vector of target variants to be partitioned. After the call, it will contain only reference-matching variants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;target_variant&gt; <br  />
 A vector containing all target-only variants (not present in the reference).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function modifies the input vector <code>target_sites</code> by resizing it. </dd>
<dd>
Order of elements may change due to the use of <code>std::swap</code>.</dd></dl>
<p>@complexity O(N), where N = number of target variants. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a361a1a76ebbe3b263e3163760007fa66_icgraph.svg" width="467" height="56"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a5dc6e4e9a5365a63291b1eeb571d9308" name="a5dc6e4e9a5365a63291b1eeb571d9308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc6e4e9a5365a63291b1eeb571d9308">&#9670;&#160;</a></span>stat_ref_panel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stat_ref_panel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>ref_file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>chrom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>end_pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inspect a reference panel file to determine chromosome and end position. </p>
<p>This function checks the index files associated with a reference panel (S1R, CSI, or TBI) to determine the contig (chromosome) and maximum position. <br  />
 It supports both <code>.s1r</code> index statistics and VCF/BCF headers when CSI/TBI indexes are present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_file_path</td><td>Path to the reference panel file (VCF/BCF/MVCF). </td></tr>
    <tr><td class="paramname">chrom</td><td>Chromosome name. If empty, it will be set automatically. <br  />
 If non-empty, the function verifies that the reference file contains it. </td></tr>
    <tr><td class="paramname">end_pos</td><td>End position of the region. Updated to the minimum of its current value and the chromosome length / max position found in the index/header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if chromosome and end position were successfully determined, <br  />
 false if an error occurred (e.g., multiple chromosomes present, index missing, or inconsistent contig name).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>If <code>.s1r</code> index statistics are available, they take priority.</li>
<li>If multiple contigs are present and <code>chrom</code> is empty, the function fails and suggests using <code>--region</code>.</li>
<li>If <code>.csi</code> or <code>.tbi</code> index is found, chromosome information is read from the VCF/BCF header.</li>
<li>For MVCF files, the reference must be indexed. Legacy M3VCF files need conversion with: <div class="fragment"><div class="line">minimac4 --update-m3vcf input.m3vcf.gz &gt; output.msav</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prints descriptive error messages to <code>stderr</code> if reference panel validation fails.</dd></dl>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="1214" height="963"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
 <div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_a5dc6e4e9a5365a63291b1eeb571d9308_icgraph.svg" width="228" height="39"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="acff4e7b0582e787ee4db091caa685c7b" name="acff4e7b0582e787ee4db091caa685c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff4e7b0582e787ee4db091caa685c7b">&#9670;&#160;</a></span>stat_tar_panel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stat_tar_panel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tar_file_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample_ids</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract sample IDs from a target panel file. </p>
<p>Opens a target haplotype/genotype file using <code>savvy::reader</code> and retrieves the list of sample IDs contained in the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tar_file_path</td><td>Path to the target panel file. </td></tr>
    <tr><td class="paramname">sample_ids</td><td>Reference to a vector that will be filled with the sample IDs read from the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was successfully opened and sample IDs were retrieved, false if the file could not be opened.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The function prints an error message to <code>stderr</code> if the file cannot be opened.</li>
<li>The existing contents of <code>sample_ids</code> are overwritten. </li>
</ul>
</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="input__prep_8hpp_acff4e7b0582e787ee4db091caa685c7b_icgraph.svg" width="228" height="39"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
